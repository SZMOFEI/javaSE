#05.01_Java语言基础(数组概述和定义格式说明)(了解)
###A:为什么要有数组(容器):
    为了存储同种数据类型的多个值
    
###B:数组概念:
	数组是存储同一种数据类型多个元素的集合,也可以看成是一个容器
	数组既可以存储基本数据类型,也可以存储引用数据类型
	
###C:数组定义格式:
	数据类型[] 数组名 = new 数据类型[数组的长度];
	
总结:代码演示如下:
```
public static void main(String[] args) {
    int x = 10;
    x = 20;
    System.out.println("x = " + x);//定义多个变量麻烦,用数组存储
    
    //数据类型[] 数组名 = new 数据类型[数组的长度];
    int[] arr = new int[5];//可以存储五个int类型的数据
    
    /*
    左边:
    int:数据类型
    []:代表的数组,几个中括号就代表几维数组
    arr:合法的标识符
    
    右边:
    new:创建新的实体或对象
    int:数据类型
    []:代表的数组
    5:代表数组的长度
    */
		
}
```

#05.02_Java语言基础(数组的初始化动态初始化)(掌握)
###A:什么是数组的初始化:
    就是为数组开辟连续的内存空间,并为每个数组元素赋值
    
###B:如何对数组进行初始化:
    a:动态初始化:只指定长度,由系统给出初始化值:
		int[] arr = new int[5];
		
	b:静态初始化:给出初始化值,由系统决定长度(格式在下面的知识点这里为了避免混淆就不列出)
	
###C:动态初始化的格式:
    数据类型[] 数组名 = new 数据类型[数组长度];
    
D:案例演示:

    输出数组名称和数组元素
    
总结:代码演示如下:
```
/*
字符类型:char默认初始化值'\u0000',
char在内存中占的两个字节,是16个二进制位,
\u0000,每一个0其实代表的是16进制的0,那么四个0就是代表16个二进制位

[I@19bb25a
[代表是数组,几个就代表几维,I代表是int类型,@是固定的,19bb25a代表的是数组的地址值
*/
class Demo2_Array {
    public static void main(String[] args) {
		//数据类型[] 数组名 = new 数据类型[数组长度];
		int[] arr = new int[5];		//动态初始化,在内存中开辟连续的5块空间
		System.out.println(arr[0]);	//系统给出默认初始化值,整数类型的都是0									
		arr[0] = 10;
		System.out.println(arr[0]);	//修改了默认值,输出为10
		System.out.println(arr);	//[I@19bb25a
	}
	
}
```

#05.03_Java语言基础(Java中的内存分配以及栈和堆的区别)
    A:栈(掌握):
    	存储局部变量(巧记:局部变量都是暂时的,暂拼音类似栈) 
    	
    B:堆(掌握):
    	存储new出来的数组或对象(巧记:对象的对拼音类似堆!!) 
    	
    C:方法区:
    	面向对象部分讲解 
    	
    D:本地方法区:
    	和系统相关 
    	
    E:寄存器:
    	给CPU使用
    	
总结:见截图

#05.04_Java语言基础(数组的内存图解1一个数组)(掌握)
A:画图演示

    一个数组
    
总结:见截图,其实跟上面的图差不多

#05.05_Java语言基础(数组的内存图解2二个数组)(了解)
A:画图演示

	二个不同的数组
	
总结:见截图,其实跟上面的图差不多

#05.06_Java语言基础(数组的内存图解3三个引用两个数组)(了解)
A:画图演示

    三个引用,有两个数组的引用指向同一个地址
    
总结:见截图,其实跟上面的图差不多

#05.07_Java语言基础(数组的初始化静态初始化及内存图)(掌握)
###A:静态初始化的格式:
    格式:数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};
    
	简化格式:
	数据类型[] 数组名 = {元素1,元素2,…};
	
B:案例演示

    对数组的解释
	输出数组名称和数组元素
	
C:画图演示:见截图

	一个数组
	
总结:代码演示如下:
```
class Demo6_Array {
	public static void main(String[] args) {
		//数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};
		//int[] arr = new int[5]{11,22,33,44,55};//不允许动静结合
	    int[] arr2 = {11,22,33,44,55};		//静态初始化的简写形式

		int[] arr;//不简写可以先声明,后赋值,简写有下面的弊端:
		arr = new int[]{11,22,33,44,55};

		//int[] arr2;
		//arr2 = {11,22,33,44,55};//简写不可以先声明,后赋值,否则报错,要注意!!

		System.out.println(arr2);
		System.out.println(arr2[4]);//记住凡是简写的都有一定的弊端,只是相对方便
		
	}
	
}
```

#05.08_Java语言基础(数组操作的两个常见小问题越界和空指针)(掌握)
A:案例演示
###a:ArrayIndexOutOfBoundsException:数组索引越界异常
    原因:你访问了不存在的索引
###b:NullPointerException:空指针异常
	原因:数组已经不再指向堆内存了,而你还用数组名去访问元素
总结:代码演示如下:
```
class Demo7_Exception {
    public static void main(String[] args) {
	    int[] arr = new int[5];		
		//System.out.println(arr[-1]);	//当访问数组中不存在的索引,会出现索引越界异常

		arr = null;
		System.out.println(arr[0]);     //当数组引用赋值为null,再去调用数组中的元素就会出现空指针异常
	}
}
```

#05.09_Java语言基础(数组的操作1遍历)(掌握)
A:案例演示(以下假设数组名是arr)

    数组遍历:就是依次输出数组中的每一个元素
	数组的属性:arr.length数组的长度
	数组的最大索引:arr.length - 1;
总结:代码演示如下:
```
public static void print(int[] arr) {//arr[i]
    for (int i = 0;i < arr.length ;i++ ) {
    	System.out.print(arr[i] + " ");//不换行打印,加个空格区分一下
    }
}
```	

#05.10_Java语言基础(数组的操作2获取最值)(掌握)
A:案例演示

	数组获取最值(获取数组中的最大值最小值)
总结:代码演示如下:
```
public static int getMax(int[] arr) {
    int max = arr[0];//首先认为数组第一个元素是最大的,
    
    for (int i = 1;i < arr.length ;i++ ) {//然后从数组的第二个元素开始遍历并比较,
    	if (max < arr[i]) {//如果其他数组元素比认为的最大值还大,
    		max = arr[i];//那么最大值应该重新赋值为其他数组元素,
    	}
    }
    
    return max;//最后返回最终的最大值
}
```	
总结:思路是先取出数组第一个元素当做最大值,然后遍历其他元素与之比较,大的赋值给它即可

###05.11_Java语言基础(数组的操作3反转)(掌握)
A:案例演示

	数组元素反转(就是把元素对调)
总结:代码演示如下:
```
public static void reverseArray(int[] arr) {
    for (int i = 0;i < arr.length / 2 ; i++) {//次数为什么除2,加入数组长度是6,你试试就知
    	//arr[0]和arr[arr.length-1-0]交换
    	//arr[1]和arr[arr.length-1-1]交换
    	//arr[2]和arr[arr.lentth-1-2]交换
    	//...总的规律就是下面的:
    
    	int temp = arr[i];
    	arr[i] = arr[arr.length-1-i];
    	arr[arr.length-1-i] = temp;
    }
}
```		
总结:第一个元素跟最后一个元素交换位置,第二个元素跟倒数第二个元素交换位置,依次类推,最后就是反转后的元素,所以交换的次数是数组的长度/2,先写个例,再先总的规律,即先写第一个跟最后一个元素交换的代码,再写总的规律代码

#05.12_Java语言基础(数组的操作4查表法)(掌握)
A:案例演示

	数组查表法(根据键盘录入数组索引,查找对应星期)
总结:代码演示如下:
```
public static char getWeek(int week) {//传入字符数组的索引
    char[] arr = {' ','一','二','三','四','五','六','日'};//用字符数组定义了一张星期表
    return arr[week];//返回星期表即字符数组中的元素,定义数组时为了一一对应,索引0给空格		//通过索引获取表中的元素
}
```	
总结:定义方法,传入索引,定义字符数组表示星期表,返回数组元素

#05.13_Java语言基础(数组的操作5基本查找)(掌握)
A:案例演示

    数组元素查找(查找指定元素第一次在数组中出现的索引)
总结:代码演示如下:
```
public static int getIndex(int[] arr,int value) {
    for (int i = 0;i < arr.length ;i++ ) {//数组的遍历
    	if (arr[i] == value) {//如果数组中的元素与查找的元素匹配,就返回索引
    		return i;
    	}
    }
    return -1;//找不到返回-1
} 
```	
总结:定义方法,遍历传入数组元素如果等于传入值,返回对应索引,否则返回-1表示找不到

#05.14_Java语言基础(二维数组概述和格式1的讲解)(了解)
A:二维数组概述:
###B:二维数组格式1
    int[][] arr = new int[3][2];
C:二维数组格式1的解释
###D:注意事项:
    a:以下格式也可以表示二维数组,建议用上面的格式1,因为便于阅读:
	    1:数据类型 数组名[][] = new 数据类型[m][n];
		2:数据类型[] 数组名[] = new 数据类型[m][n];
		
	b:注意下面定义的区别:
    	int x;
    	int y;
    	int x,y;
    	
    	int[] x;
    	int[] y[];//1↓
    	
    	int[] x,y[];//x是一维数组,y是二维数组,其实就是上面的1↑
E:案例演示

	定义二维数组,输出二维数组名称,一维数组名称,一个元素
总结:代码演示如下:
```
class Demo1_Array {
	public static void main(String[] args) {
		int[][] arr = new int[3][2];
		/*
		这是一个二维数组
		这个二维数组中有3个一维数组,
		每个一维数组中有2个元素

		[[I@19bb25a	//二维数组的地址值
		[I@da6bf4	//一维数组的地址值
		0		//元素值
		*/
		System.out.println(arr);	//二维数组
		System.out.println(arr[0]);	//二维数组中的第一个元素就是一维数组
		System.out.println(arr[0][0]);	//二维数组中的第一个一维数组的第一个元素
	}
}
```
总结:其实只要明白一句话就可以了:二维数组的元素是一维数组,只不过数组是引用类型,存的是一维数组的地址值

#05.15_Java语言基础(二维数组格式1的内存图解)(了解)
A:画图演示

    画图讲解上面的二维数组名称,一维数组名称,一个元素的值的问题
总结:见截图,但是总的来说就是二维数组存储的元素是一维数组的地址值,然后通过地址值指向数组实体

#05.16_Java语言基础(二维数组格式2的讲解及其内存图解)(了解)
###A:二维数组格式2:
    int[][] arr = new int[3][];//这个二维数组中有三个元素,存储的是一维数组的地址值,这时的地址值赋值为null
B:二维数组格式2的解释
C:案例演示

	讲解格式,输出数据,并画内存图:见截图
总结:代码演示如下:
```
class Demo3_Array {
    public static void main(String[] args) {
        int[][] arr = new int[3][];//这个二维数组中有三个元素,存储的是一维数组的地址值,这时的地址值赋值为null
        
        System.out.println(arr[0]);//null
        System.out.println(arr[1]);//null
        System.out.println(arr[2]);//null
        arr[0] = new int[3];	//第一个一维数组中可以存储三个int值
        arr[1] = new int[5];	//第二个一维数组中可以存储五个int值
        System.out.println("------------------");
        System.out.println(arr[0]);//地址值
        System.out.println(arr[1]);//地址值
        System.out.println(arr[2]);//默认地址值null
      }
}
```
总结:格式1存储的一维数组元素个数都是一样的,格式2可以存储不同个数元素的一位数组,所以格式2存的是未知一位数组的地址值null

#05.17_Java语言基础(二维数组格式3的讲解及其内存图解)(了解)
###A:二维数组格式3
    int[][] arr = {{1,2,3},{4,5},{6,7,8,9}};
B:二维数组格式3的解释
C:案例演示

	讲解格式,输出数据,并画内存图:见截图,其实跟上面是一样的
总结:代码演示如下:
```
class Demo4_Array {
    public static void main(String[] args) {
        int[][] arr = {{1,2,3},{4,5},{6,7,8,9}};//这是一个二维数组,这个二维数组中每个大括号都代表一个一维数组
        System.out.println(arr);		//[[I@19bb25a,二维数组的地址值
        System.out.println(arr[0]);		//[I@da6bf4,一维数组的地址值
        System.out.println(arr[0][0]);		//1,一维数组中的第一个元素值
    }
}
```
总结:格式1,格式2像一维数组的动态初始化,而格式3像一维数组的静态初始化,不要忘了这个二维数组的格式3,也常常使用,如下练习所示↓

#05.18_Java语言基础(二维数组练习1遍历)(掌握)
A:案例演示

    需求:二维数组遍历:
	外循环控制的是二维数组的长度,其实就是一维数组的个数
	内循环控制的是一维数组的长度
总结:代码演示如下:
```
class Test1_Array {
	public static void main(String[] args) {
		int[][] arr = {{1,2,3},{4,5},{6,7,8,9}};//这个二维数组有三个元素,即每个大括号代表的一维数组

		for (int i = 0;i < arr.length ;i++ ) {//获取到每个二维数组中的一维数组,
			for (int j = 0;j < arr[i].length ;j++ ) {//获取每个一维数组中的元素
				System.out.print(arr[i][j] + " ");
			}

			System.out.println();//换行
		}
	}
}
```
总结:其实也是你要知道二维数组的元素是一维数组,那么上面的arr[i]可以表示每一个一维数组

###05.19_Java语言基础(二维数组练习2求和)(掌握)
A:案例演示

    需求:公司年销售额求和
    某公司按照季度和月份统计的数据如下:单位(万元)
    第一季度:22,66,44
    第二季度:77,33,88
    第三季度:25,45,65
    第四季度:11,66,99
总结:代码演示如下:
```
class Test2_Array {
	public static void main(String[] args) {
		int[][] arr = {{22,66,44},{77,33,88},{25,45,65},{11,66,99}};

		int sum = 0;//定义变量,记录每次相加的结果
		for (int i = 0;i < arr.length ;i++ ) {		 //获取每一个一维数组
			for (int j = 0;j < arr[i].length ;j++ ) {//获取每一个一维数组中的元素
				sum = sum + arr[i][j];//累加,其实就是二维数组遍历的一种变形
			}
		}

		System.out.println(sum);
	}
}
```
总结:其实本质上还是要明白二维数组的元素是一维数组,然后对二维数组进行遍历,再与临时变量相加求和即可

#05.20_Java语言基础(思考题Java中的参数传递问题及图解)(掌握)
A:案例演示

    看程序写结果,并画内存图解释
    public static void main(String[] args) {
    	int a = 10;
    	int b = 20;
    	System.out.println("a:"+a+",b:"+b);//10,20
    	change(a,b);
    	System.out.println("a:"+a+",b:"+b);//10,20
    
    	int[] arr = {1,2,3,4,5};
    	change(arr);
    	System.out.println(arr[1]);//4
    }
    
    public static void change(int a,int b) {
    	System.out.println("a:"+a+",b:"+b);
    	a = b;
    	b = a + b;
    	System.out.println("a:"+a+",b:"+b);//20,40
    }
    
    public static void change(int[] arr) {
    	for(int x=0; x<arr.length; x++) {
    		if(arr[x]%2==0) {
    			arr[x]*=2;
    		}
    	}
    }
总结:
基本数据类型的值传递,不改变原值,因为调用后就会弹栈,局部变量随之消失,
引用数据类型的值传递,改变原值,因为即使方法弹栈,但是堆内存数组对象还在,可以通过地址继续访问

###Java中到底是传值还是传址,说法有两种:
    1,既是传值,也是传地址,基本数据类型传递的值,引用数据类型传递的地址
    
    2,java中只有传值,因为地址值也是值(出去面试都说这种,支持者是高司令(java之父))

#05.21_day05总结
    把今天的知识点总结一遍:
    数组-数组动态初始化-数组静态初始化-数组越界与空指针异常-数组操作如求最值,反转,查表,查找-
    二维数组的元素是一维数组,即存储的是地址值-二维数组遍历求和-基本数据类型的值传递和引用类型的地址值传递
    
